# Reachable Sets for 2D Controlled Systems

Исследовательский проект по построению множеств достижимости плоской управляемой системы разными методами и сравнению их по расстоянию Хаусдорфа.

Проект реализует:

1. Построение множества достижимости двумерной управляемой системы сеточным методом (метод «облака точек» с прореживанием).
2. Ускорение сеточного метода с помощью PyTorch (CPU/GPU).
3. Построение границы множества достижимости через задачи оптимального управления в Pyomo.
4. Отображение двух множеств на одном графике.
5. Вычисление расстояния по Хаусдорфу между двумя аппроксимациями и его визуализацию.

---

## 1. Математическая постановка

Рассматривается управляемая система:

\[
\dot x(t) = f(x(t), u(t)), \quad x(t) \in \mathbb{R}^2, \ u(t) \in P, \ t \in [0, T],
\]

с фиксированным начальным состоянием \(x(0) = x_0\).

В данном демо-проекте динамика выбрана простой линейной:

\[
\begin{cases}
\dot x_1 = x_2 + u_1, \\
\dot x_2 = -x_1 + u_2,
\end{cases}
\]

где \(u = (u_1, u_2)\) — двумерное управление с ограничением, например, в диске

\[
P = \{ u \in \mathbb{R}^2 : \|u\|_2 \le u_{\max} \}.
\]

Множество достижимости к моменту \(T\):

\[
\mathcal{R}(T) = \{ x(T) : \dot x = f(x,u), \ x(0)=x_0, \ u(\cdot) \in \mathcal{U} \}.
\]

В проекте строятся две численные аппроксимации:

- \(\mathcal{R}_{\text{grid}}(T)\) — через сеточный (point-cloud) метод,
- \(\mathcal{R}_{\text{OC}}(T)\) — через решения задач оптимального управления по направлениям.

---

## 2. Возможности проекта (что реализовано)

### 2.1. Сеточный метод множества достижимости

- Дискретизация времени: \(t_0=0 < t_1 < \dots < t_N=T\), шаг \(\Delta t = T/N\).
- Дискретный набор управлений \( \{u_k\}_{k=1}^{M} \subset P\) (обычно равномерная сетка по углу на окружности/эллипсе).
- Итерация по времени:

  - На шаге \(i\) есть облако точек \(W_i\).
  - Для каждой точки \(x \in W_i\) и каждого управления \(u_k\) вычисляется
    \[
    x^{\text{new}} = x + \Delta t \, f(x, u_k)
    \]
    (схема Эйлера).
  - Все полученные точки собираются в облако \(\tilde W_{i+1}\).
  - К \(\tilde W_{i+1}\) применяется процедура прореживания → получаем \(W_{i+1}\).

- После \(N\) шагов \(W_N\) считается аппроксимацией \(\mathcal{R}_{\text{grid}}(T)\).

Реализовано два типа прореживания:

1. **Grid-based thinning** — сетка в \(\mathbb{R}^2\), один представитель на ячейку.
2. **Poisson Disk thinning** — жадный алгоритм с минимальным расстоянием между точками (Poisson Disk Sampling-style).

Для ускорения:

- Базовая версия — NumPy (CPU).
- Ускоренная версия — PyTorch (CPU/GPU), векторизованное вычисление всех переходов \((x,u)\).

### 2.2. Граница множества через задачи оптимального управления (Pyomo)

Для направления \(\ell(\phi) = (\cos\phi, \sin\phi)\) решается задача:

\[
\max_{u(\cdot)} \ \langle \ell(\phi), x(T) \rangle
\]

при ограничениях динамики и допустимых управлений.

Численная постановка:

- Дискретизация времени тем же шагом \(\Delta t\).
- Переменные: \(x_k \in \mathbb{R}^2\), \(u_k \in \mathbb{R}^2\) для \(k=0,\dots,N-1\).
- Ограничения динамики (Эйлер):

  \[
  x_{k+1} = x_k + \Delta t \, f(x_k, u_k).
  \]

- Ограничения на управление, например \(\|u_k\|_2 \le u_{\max}\).
- Цель: максимизировать \(\langle \ell(\phi), x_N \rangle\) (реализовано как минимизация отрицательного значения).

Повторяя это для набора углов \(\phi_j\) (равномерно по \([0,2\pi)\)), получаем граничные точки \(x_{\phi_j}(T)\), образующие \(\partial \mathcal{R}_{\text{OC}}(T)\).

### 2.3. Расстояние по Хаусдорфу

Для двух конечных множеств \(A, B \subset \mathbb{R}^2\):

\[
d_H(A,B) = \max\left\{\max_{a\in A}\min_{b\in B}\|a-b\|,\ \max_{b\in B}\min_{a\in A}\|b-a\|\right\}.
\]

Реализовано:

- Вычисление направленных расстояний \(d(A,B)\) и \(d(B,A)\) (через cKDTree или brute force).
- Поиск пары точек \((a^*, b^*)\), где достигается максимум (приближённо).
- Возврат структуры `HausdorffResult` с:
  - `distance`
  - `point_a`
  - `point_b`.

Визуализация:

- Облако точек сеточного метода.
- Ломаная граница \(\mathcal{R}_{\text{OC}}(T)\).
- Маркеры для \(a^*\) и \(b^*\), отрезок между ними и текст с численным значением расстояния.

---

## 3. Структура проекта

Основные модули:

- `system.py`  
  Описание управляемой системы:
  - класс `ControlledSystem` (NumPy-динамика `f_numpy`);
  - класс `ControlledSystemTorch` (PyTorch-динамика `f_torch`).

- `controls.py`  
  Генерация дискретных множеств управлений:
  - `generate_controls_disk` — точки на окружности диска \(\|u\| \le u_{\max}\);
  - `generate_controls_box` — сетка в прямоугольнике;
  - `generate_controls_ellipse` — сетка по эллипсу.

- `thinning.py`  
  Прореживание облака точек:
  - `thin_grid(points, h)` — сетка с шагом `h`, один представитель на ячейку;
  - `thin_poisson(points, r)` — Poisson Disk-подобный greedy алгоритм с минимальным расстоянием `r`.

- `backend_numpy.py`  
  Базовый backend:
  - `propagate_numpy(system, states, controls, dt)` — один шаг по времени для всех пар `(state, control)`.

- `backend_torch.py`  
  Ускоренный backend на PyTorch:
  - `propagate_torch(system, states, controls, dt, device)` — аналог `propagate_numpy`, но на тензорах (CPU/GPU).

- `grid_reachability.py`  
  Высокоуровневый сеточный метод:
  - `ReachabilityConfig` — параметры метода (T, шаги, тип прореживания, backend);
  - `compute_reachable_set_grid(system, x0, controls, cfg)` — построение множества достижимости \(\mathcal{R}_{\text{grid}}(T)\).

- `ocp_pyomo.py`  
  Задачи оптимального управления:
  - `solve_ocp_direction(phi, system, x0, T, num_time_steps, solver_name)` — решение ОУ для одного направления;
  - `compute_oc_boundary(system, x0, T, num_time_steps, num_directions, solver_name)` — граничный контур;
  - `compute_oc_boundary_bruteforce(...)` — быстрый грубый вариант через постоянные управления и перебор по окружности/эллипсу.

- `hausdorff.py`
  - `HausdorffResult` — результат вычисления расстояния;
  - `hausdorff_distance(A, B)` — симметричное расстояние по Хаусдорфу и критическая пара точек.

- `plotting.py`
  - `plot_reachable_sets(R_grid, R_oc, hd, title, save_path)` — единый график с множествами и отрезком Хаусдорфа.

- `experiment.py`
  - `run_experiment()` — сценарий, который:
    1. Строит сеточное множество достижимости (NumPy, grid thinning).
    2. Строит вариант с Poisson-thinning (опционально).
    3. Строит сеточное множество на Torch backend и измеряет ускорение.
    4. Строит границу \(\mathcal{R}_{\text{OC}}(T)\) через Pyomo.
    5. Считает расстояние по Хаусдорфу между \(\mathcal{R}_{\text{grid}}\) и \(\mathcal{R}_{\text{OC}}\).
    6. Визуализирует всё на одном графике.

---

## 4. Установка и зависимости

### 4.1. Базовые библиотеки

Проект рассчитан на Python 3.10+.

Минимальные зависимости:

- `numpy`
- `matplotlib`

Для ускорения и решателя:

- `torch` (PyTorch) — для ускоренного backend’а;
- `pyomo` — для задач оптимального управления;
- внешний солвер (например, `ipopt`), который Pyomo будет вызывать.

Опционально (для ускорения Хаусдорфа):

- `scipy` (модуль `scipy.spatial.cKDTree`).

Пример установки (локально):

```bash
pip install numpy matplotlib pyomo torch scipy
# далее установить и подключить внешнее решение типа IPOPT или другой доступный солвер
